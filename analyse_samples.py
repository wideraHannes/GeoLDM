#!/usr/bin/env python3
"""
Molecule Analysis Tool for GeoLDM

This script analyzes molecular properties of 3D structures generated by GeoLDM,
including synthetic accessibility score (SA) and drug-likeness (QED).
"""

# Standard library imports
import os
import glob
import argparse
from typing import Tuple, List, Dict, Optional, Union, Any

# Third-party imports
import numpy as np
import pandas as pd
import torch
from tqdm import tqdm
from rdkit import Chem
from rdkit.Chem import QED, AllChem, rdMolDescriptors

# Project-specific imports
from qm9.rdkit_functions import build_molecule
from configs.datasets_config import get_dataset_info


def read_molecule_file(file_path: str) -> Tuple[np.ndarray, np.ndarray]:
    """
    Read a molecular structure from a .txt file.

    Args:
        file_path: Path to the molecule file

    Returns:
        Tuple containing:
            - positions: numpy array of shape (num_atoms, 3) with xyz coordinates
            - atom_types: numpy array of shape (num_atoms,) with atom type indices

    Format of the input file:
        num_atoms

        atom_symbol x y z
        atom_symbol x y z
        ...
    """
    with open(file_path, "r") as f:
        lines = f.readlines()

    num_atoms = int(lines[0].strip())
    positions = []
    atom_types = []

    # Map atom symbols to GeoLDM atom types based on QM9 encoding
    symbol_to_type = {"H": 0, "C": 1, "N": 2, "O": 3, "F": 4}

    for i in range(2, 2 + num_atoms):
        parts = lines[i].strip().split()
        if len(parts) != 4:
            continue

        symbol, x, y, z = parts
        positions.append([float(x), float(y), float(z)])
        atom_types.append(symbol_to_type.get(symbol, 0))  # Default to H if unknown

    return np.array(positions), np.array(atom_types)


def calculate_sa_score(mol: Chem.Mol) -> Optional[float]:
    """
    Calculate synthetic accessibility score for a molecule.

    Args:
        mol: RDKit molecule object

    Returns:
        Score between 1 (easy to make) and 10 (very difficult to make),
        or None if calculation fails
    """
    if mol is None:
        return None

    try:
        # Try the different possible import paths for SA_Score
        try:
            from rdkit.Contrib.SA_Score import sascorer

            return sascorer.calculateScore(mol)
        except (ImportError, AttributeError):
            try:
                from rdkit.Contrib import SA_Score

                return SA_Score.sascorer.calculateScore(mol)
            except AttributeError:
                try:
                    from rdkit.Contrib import SA_Score

                    return SA_Score.calculateScore(mol)
                except (ImportError, AttributeError):
                    import rdkit.Contrib.SA_Score.sascorer as sascorer

                    return sascorer.calculateScore(mol)
    except Exception as e:
        print(f"Warning: SA_Score calculation failed: {e}")
        return None


def calculate_molecular_properties(mol: Chem.Mol, mol_id: str) -> Dict[str, Any]:
    """
    Calculate various molecular properties for a given molecule.

    Args:
        mol: RDKit molecule object
        mol_id: Molecule identifier

    Returns:
        Dictionary with calculated properties
    """
    result = {"molecule_id": mol_id}

    try:
        if mol is not None:
            Chem.SanitizeMol(mol)
            result.update(
                {
                    "sa_score": calculate_sa_score(mol),
                    "qed": QED.qed(mol),
                    "mol_weight": rdMolDescriptors.CalcExactMolWt(mol),
                    "smiles": Chem.MolToSmiles(mol),
                    "error": None,
                }
            )
        else:
            raise ValueError("Invalid molecule")
    except Exception as e:
        print(f"Error processing molecule {mol_id}: {e}")
        result.update(
            {
                "sa_score": None,
                "qed": None,
                "mol_weight": None,
                "smiles": None,
                "error": str(e),
            }
        )

    return result


def analyze_molecules(
    molecules_dir: str, output_file: Optional[str] = None
) -> pd.DataFrame:
    """
    Analyze properties of all molecules in the specified directory.

    Args:
        molecules_dir: Directory containing molecule files
        output_file: Path where to save results as CSV

    Returns:
        DataFrame with molecule properties and statistics
    """
    # Get all molecule files
    molecule_files = sorted(glob.glob(os.path.join(molecules_dir, "molecule_*.txt")))

    if not molecule_files:
        print(f"No molecule files found in {molecules_dir}")
        return pd.DataFrame()

    # Get dataset info for QM9 with hydrogens
    dataset_info = get_dataset_info("qm9", remove_h=False)
    results = []

    # Process each molecule file
    for file_path in tqdm(molecule_files, desc="Analyzing molecules"):
        # Extract molecule ID from filename
        mol_id = (
            os.path.basename(file_path).replace("molecule_", "").replace(".txt", "")
        )

        # Read and convert molecule structure
        positions, atom_types = read_molecule_file(file_path)
        positions_tensor = torch.tensor(positions, dtype=torch.float32)
        atom_types_tensor = torch.tensor(atom_types, dtype=torch.long)

        # Convert to RDKit molecule and calculate properties
        mol = build_molecule(positions_tensor, atom_types_tensor, dataset_info)
        results.append(calculate_molecular_properties(mol, mol_id))

    # Create a DataFrame with results
    df = pd.DataFrame(results)

    # Print statistics
    print_molecule_statistics(df)

    # Save results if output file is specified
    if output_file:
        df.to_csv(output_file, index=False)
        print(f"\nResults saved to {output_file}")

    return df


def print_molecule_statistics(df: pd.DataFrame) -> None:
    """
    Print statistics about molecule properties.

    Args:
        df: DataFrame containing molecule properties
    """
    print("\nSynthetic Accessibility Score (SA) Statistics:")
    print(f"Mean SA Score: {df['sa_score'].mean():.3f}")
    print(f"Median SA Score: {df['sa_score'].median():.3f}")
    print(f"Min SA Score: {df['sa_score'].min():.3f}")
    print(f"Max SA Score: {df['sa_score'].max():.3f}")

    print("\nDrug-likeness (QED) Statistics:")
    print(f"Mean QED: {df['qed'].mean():.3f}")
    print(f"Median QED: {df['qed'].median():.3f}")

    # Add information about successful vs. failed analyses
    error_count = df["error"].notna().sum()
    total_count = len(df)
    success_rate = (
        ((total_count - error_count) / total_count) * 100 if total_count > 0 else 0
    )

    print(
        f"\nAnalysis success rate: {success_rate:.1f}% ({total_count - error_count}/{total_count})"
    )


def main():
    """Parse command-line arguments and run the analysis."""
    parser = argparse.ArgumentParser(
        description="Calculate molecular properties for GeoLDM-generated molecules"
    )
    parser.add_argument(
        "--dir",
        type=str,
        default="outputs/qm9_latent2/eval/molecules",
        help="Directory containing molecule files",
    )
    parser.add_argument(
        "--output",
        type=str,
        default="molecule_analysis.csv",
        help="Output CSV file for results",
    )

    args = parser.parse_args()
    analyze_molecules(args.dir, args.output)


if __name__ == "__main__":
    main()
